'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.zipLongest = exports.izipLongest = exports.izip = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.chain = chain;
exports.count = count;
exports.compress = compress;
exports.cycle = cycle;
exports.dropwhile = dropwhile;
exports.groupby = groupby;
exports.icompress = icompress;
exports.ifilter = ifilter;
exports.imap = imap;
exports.islice = islice;
exports.izip2 = izip2;
exports.izip3 = izip3;
exports.izipLongest2 = izipLongest2;
exports.izipLongest3 = izipLongest3;
exports.izipMany = izipMany;
exports.permutations = permutations;
exports.repeat = repeat;
exports.takewhile = takewhile;
exports.zipLongest2 = zipLongest2;
exports.zipLongest3 = zipLongest3;
exports.zipMany = zipMany;

var _regeneratorRuntime2 = require('regenerator-runtime');

var _regeneratorRuntime3 = _interopRequireDefault(_regeneratorRuntime2);

var _builtins = require('./builtins');

var _moreItertools = require('./more-itertools');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var _marked = /*#__PURE__*/_regenerator2.default.mark(count),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(cycle),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(dropwhile),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(groupby),
    _marked5 = /*#__PURE__*/_regenerator2.default.mark(icompress),
    _marked6 = /*#__PURE__*/_regenerator2.default.mark(ifilter),
    _marked7 = /*#__PURE__*/_regenerator2.default.mark(imap),
    _marked8 = /*#__PURE__*/_regenerator2.default.mark(islice),
    _marked9 = /*#__PURE__*/_regenerator2.default.mark(izip2),
    _marked10 = /*#__PURE__*/_regenerator2.default.mark(izip3),
    _marked11 = /*#__PURE__*/_regenerator2.default.mark(izipLongest2),
    _marked12 = /*#__PURE__*/_regenerator2.default.mark(izipLongest3),
    _marked13 = /*#__PURE__*/_regenerator2.default.mark(izipMany),
    _marked14 = /*#__PURE__*/_regenerator2.default.mark(permutations),
    _marked15 = /*#__PURE__*/_regenerator2.default.mark(repeat),
    _marked16 = /*#__PURE__*/_regenerator2.default.mark(takewhile); //  strict

// eslint-disable-next-line no-unused-vars


var SENTINEL = Symbol();

function composeAnd(f1, f2) {
    return function (n) {
        return f1(n) && f2(n);
    };
}

function slicePredicate(start, stop, step) {
    // If stop is not provided (= undefined), then interpret the start value as the stop value
    var _start = start,
        _stop = stop,
        _step = step;
    if (_stop === undefined) {
        var _ref = [0, _start];
        _start = _ref[0];
        _stop = _ref[1];
    }

    var pred = function pred(n) {
        return n >= _start;
    };

    if (_stop !== null) {
        var stopNotNull = _stop;
        pred = composeAnd(pred, function (n) {
            return n < stopNotNull;
        });
    }

    if (_step > 1) {
        pred = composeAnd(pred, function (n) {
            return (n - _start) % _step === 0;
        });
    }

    return pred;
}

/**
 * Returns an iterator that returns elements from the first iterable until it
 * is exhausted, then proceeds to the next iterable, until all of the iterables
 * are exhausted.  Used for treating consecutive sequences as a single
 * sequence.
 */
function chain() {
    for (var _len = arguments.length, iterables = Array(_len), _key = 0; _key < _len; _key++) {
        iterables[_key] = arguments[_key];
    }

    return (0, _moreItertools.flatten)(iterables);
}

/**
 * Returns an iterator that counts up values starting with number `start`
 * (default 0), incrementing by `step`.  To decrement, use a negative step
 * number.
 */
function count() {
    var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var step = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n;
    return _regenerator2.default.wrap(function count$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    n = start;

                case 1:
                    _context.next = 3;
                    return n;

                case 3:
                    n += step;

                case 4:
                    _context.next = 1;
                    break;

                case 6:
                case 'end':
                    return _context.stop();
            }
        }
    }, _marked, this);
}

/**
 * Non-lazy version of icompress().
 */
function compress(data, selectors) {
    return [].concat(_toConsumableArray(icompress(data, selectors)));
}

/**
 * Returns an iterator producing elements from the iterable and saving a copy
 * of each.  When the iterable is exhausted, return elements from the saved
 * copy.  Repeats indefinitely.
 */
function cycle(iterable) {
    var saved, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step2, element, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step3, _element;

    return _regenerator2.default.wrap(function cycle$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    saved = [];
                    _iteratorNormalCompletion = true;
                    _didIteratorError = false;
                    _iteratorError = undefined;
                    _context2.prev = 4;
                    _iterator = iterable[Symbol.iterator]();

                case 6:
                    if (_iteratorNormalCompletion = (_step2 = _iterator.next()).done) {
                        _context2.next = 14;
                        break;
                    }

                    element = _step2.value;
                    _context2.next = 10;
                    return element;

                case 10:
                    saved.push(element);

                case 11:
                    _iteratorNormalCompletion = true;
                    _context2.next = 6;
                    break;

                case 14:
                    _context2.next = 20;
                    break;

                case 16:
                    _context2.prev = 16;
                    _context2.t0 = _context2['catch'](4);
                    _didIteratorError = true;
                    _iteratorError = _context2.t0;

                case 20:
                    _context2.prev = 20;
                    _context2.prev = 21;

                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }

                case 23:
                    _context2.prev = 23;

                    if (!_didIteratorError) {
                        _context2.next = 26;
                        break;
                    }

                    throw _iteratorError;

                case 26:
                    return _context2.finish(23);

                case 27:
                    return _context2.finish(20);

                case 28:
                    if (!(saved.length > 0)) {
                        _context2.next = 57;
                        break;
                    }

                    _iteratorNormalCompletion2 = true;
                    _didIteratorError2 = false;
                    _iteratorError2 = undefined;
                    _context2.prev = 32;
                    _iterator2 = saved[Symbol.iterator]();

                case 34:
                    if (_iteratorNormalCompletion2 = (_step3 = _iterator2.next()).done) {
                        _context2.next = 41;
                        break;
                    }

                    _element = _step3.value;
                    _context2.next = 38;
                    return _element;

                case 38:
                    _iteratorNormalCompletion2 = true;
                    _context2.next = 34;
                    break;

                case 41:
                    _context2.next = 47;
                    break;

                case 43:
                    _context2.prev = 43;
                    _context2.t1 = _context2['catch'](32);
                    _didIteratorError2 = true;
                    _iteratorError2 = _context2.t1;

                case 47:
                    _context2.prev = 47;
                    _context2.prev = 48;

                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }

                case 50:
                    _context2.prev = 50;

                    if (!_didIteratorError2) {
                        _context2.next = 53;
                        break;
                    }

                    throw _iteratorError2;

                case 53:
                    return _context2.finish(50);

                case 54:
                    return _context2.finish(47);

                case 55:
                    _context2.next = 28;
                    break;

                case 57:
                case 'end':
                    return _context2.stop();
            }
        }
    }, _marked2, this, [[4, 16, 20, 28], [21,, 23, 27], [32, 43, 47, 55], [48,, 50, 54]]);
}

/**
 * Returns an iterator that drops elements from the iterable as long as the
 * predicate is true; afterwards, returns every remaining element.  Note, the
 * iterator does not produce any output until the predicate first becomes
 * false.
 */
function dropwhile(iterable, predicate) {
    var it, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step4, value, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step5, _value;

    return _regenerator2.default.wrap(function dropwhile$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    it = (0, _builtins.iter)(iterable);
                    _iteratorNormalCompletion3 = true;
                    _didIteratorError3 = false;
                    _iteratorError3 = undefined;
                    _context3.prev = 4;
                    _iterator3 = it[Symbol.iterator]();

                case 6:
                    if (_iteratorNormalCompletion3 = (_step4 = _iterator3.next()).done) {
                        _context3.next = 15;
                        break;
                    }

                    value = _step4.value;

                    if (predicate(value)) {
                        _context3.next = 12;
                        break;
                    }

                    _context3.next = 11;
                    return value;

                case 11:
                    return _context3.abrupt('break', 15);

                case 12:
                    _iteratorNormalCompletion3 = true;
                    _context3.next = 6;
                    break;

                case 15:
                    _context3.next = 21;
                    break;

                case 17:
                    _context3.prev = 17;
                    _context3.t0 = _context3['catch'](4);
                    _didIteratorError3 = true;
                    _iteratorError3 = _context3.t0;

                case 21:
                    _context3.prev = 21;
                    _context3.prev = 22;

                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }

                case 24:
                    _context3.prev = 24;

                    if (!_didIteratorError3) {
                        _context3.next = 27;
                        break;
                    }

                    throw _iteratorError3;

                case 27:
                    return _context3.finish(24);

                case 28:
                    return _context3.finish(21);

                case 29:
                    _iteratorNormalCompletion4 = true;
                    _didIteratorError4 = false;
                    _iteratorError4 = undefined;
                    _context3.prev = 32;
                    _iterator4 = it[Symbol.iterator]();

                case 34:
                    if (_iteratorNormalCompletion4 = (_step5 = _iterator4.next()).done) {
                        _context3.next = 41;
                        break;
                    }

                    _value = _step5.value;
                    _context3.next = 38;
                    return _value;

                case 38:
                    _iteratorNormalCompletion4 = true;
                    _context3.next = 34;
                    break;

                case 41:
                    _context3.next = 47;
                    break;

                case 43:
                    _context3.prev = 43;
                    _context3.t1 = _context3['catch'](32);
                    _didIteratorError4 = true;
                    _iteratorError4 = _context3.t1;

                case 47:
                    _context3.prev = 47;
                    _context3.prev = 48;

                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }

                case 50:
                    _context3.prev = 50;

                    if (!_didIteratorError4) {
                        _context3.next = 53;
                        break;
                    }

                    throw _iteratorError4;

                case 53:
                    return _context3.finish(50);

                case 54:
                    return _context3.finish(47);

                case 55:
                case 'end':
                    return _context3.stop();
            }
        }
    }, _marked3, this, [[4, 17, 21, 29], [22,, 24, 28], [32, 43, 47, 55], [48,, 50, 54]]);
}

function groupby(iterable) {
    var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.primitiveIdentity;
    var it, currentValue, currentKey, targetKey, grouper, nextVal;
    return _regenerator2.default.wrap(function groupby$(_context5) {
        while (1) {
            switch (_context5.prev = _context5.next) {
                case 0:
                    it = (0, _builtins.iter)(iterable);
                    currentValue = void 0;
                    // $FlowFixMe - deliberate use of the SENTINEL symbol

                    currentKey = SENTINEL;
                    targetKey = currentKey;
                    grouper = /*#__PURE__*/_regenerator2.default.mark(function grouper(tgtKey) {
                        var nextVal;
                        return _regenerator2.default.wrap(function grouper$(_context4) {
                            while (1) {
                                switch (_context4.prev = _context4.next) {
                                    case 0:
                                        if (!(currentKey === tgtKey)) {
                                            _context4.next = 10;
                                            break;
                                        }

                                        _context4.next = 3;
                                        return currentValue;

                                    case 3:
                                        nextVal = it.next();

                                        if (!nextVal.done) {
                                            _context4.next = 6;
                                            break;
                                        }

                                        return _context4.abrupt('return');

                                    case 6:
                                        currentValue = nextVal.value;
                                        currentKey = keyFn(currentValue);
                                        _context4.next = 0;
                                        break;

                                    case 10:
                                    case 'end':
                                        return _context4.stop();
                                }
                            }
                        }, grouper, this);
                    });

                case 5:
                    if (!(currentKey === targetKey)) {
                        _context5.next = 14;
                        break;
                    }

                    nextVal = it.next();

                    if (!nextVal.done) {
                        _context5.next = 10;
                        break;
                    }

                    // $FlowFixMe - deliberate use of the SENTINEL symbol
                    currentKey = SENTINEL;
                    return _context5.abrupt('return');

                case 10:
                    currentValue = nextVal.value;
                    currentKey = keyFn(currentValue);
                    _context5.next = 5;
                    break;

                case 14:

                    targetKey = currentKey;
                    _context5.next = 17;
                    return [currentKey, grouper(targetKey)];

                case 17:
                    _context5.next = 5;
                    break;

                case 19:
                case 'end':
                    return _context5.stop();
            }
        }
    }, _marked4, this);
}

/**
 * Returns an iterator that filters elements from data returning only those
 * that have a corresponding element in selectors that evaluates to `true`.
 * Stops when either the data or selectors iterables has been exhausted.
 */
function icompress(data, selectors) {
    var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step6, _ref2, _ref3, d, s;

    return _regenerator2.default.wrap(function icompress$(_context6) {
        while (1) {
            switch (_context6.prev = _context6.next) {
                case 0:
                    _iteratorNormalCompletion5 = true;
                    _didIteratorError5 = false;
                    _iteratorError5 = undefined;
                    _context6.prev = 3;
                    _iterator5 = izip(data, selectors)[Symbol.iterator]();

                case 5:
                    if (_iteratorNormalCompletion5 = (_step6 = _iterator5.next()).done) {
                        _context6.next = 16;
                        break;
                    }

                    _ref2 = _step6.value;
                    _ref3 = _slicedToArray(_ref2, 2);
                    d = _ref3[0];
                    s = _ref3[1];

                    if (!s) {
                        _context6.next = 13;
                        break;
                    }

                    _context6.next = 13;
                    return d;

                case 13:
                    _iteratorNormalCompletion5 = true;
                    _context6.next = 5;
                    break;

                case 16:
                    _context6.next = 22;
                    break;

                case 18:
                    _context6.prev = 18;
                    _context6.t0 = _context6['catch'](3);
                    _didIteratorError5 = true;
                    _iteratorError5 = _context6.t0;

                case 22:
                    _context6.prev = 22;
                    _context6.prev = 23;

                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }

                case 25:
                    _context6.prev = 25;

                    if (!_didIteratorError5) {
                        _context6.next = 28;
                        break;
                    }

                    throw _iteratorError5;

                case 28:
                    return _context6.finish(25);

                case 29:
                    return _context6.finish(22);

                case 30:
                case 'end':
                    return _context6.stop();
            }
        }
    }, _marked5, this, [[3, 18, 22, 30], [23,, 25, 29]]);
}

/**
 * Returns an iterator that filters elements from iterable returning only those
 * for which the predicate is true.
 */
function ifilter(iterable, predicate) {
    var _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step7, value;

    return _regenerator2.default.wrap(function ifilter$(_context7) {
        while (1) {
            switch (_context7.prev = _context7.next) {
                case 0:
                    _iteratorNormalCompletion6 = true;
                    _didIteratorError6 = false;
                    _iteratorError6 = undefined;
                    _context7.prev = 3;
                    _iterator6 = iterable[Symbol.iterator]();

                case 5:
                    if (_iteratorNormalCompletion6 = (_step7 = _iterator6.next()).done) {
                        _context7.next = 13;
                        break;
                    }

                    value = _step7.value;

                    if (!predicate(value)) {
                        _context7.next = 10;
                        break;
                    }

                    _context7.next = 10;
                    return value;

                case 10:
                    _iteratorNormalCompletion6 = true;
                    _context7.next = 5;
                    break;

                case 13:
                    _context7.next = 19;
                    break;

                case 15:
                    _context7.prev = 15;
                    _context7.t0 = _context7['catch'](3);
                    _didIteratorError6 = true;
                    _iteratorError6 = _context7.t0;

                case 19:
                    _context7.prev = 19;
                    _context7.prev = 20;

                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                    }

                case 22:
                    _context7.prev = 22;

                    if (!_didIteratorError6) {
                        _context7.next = 25;
                        break;
                    }

                    throw _iteratorError6;

                case 25:
                    return _context7.finish(22);

                case 26:
                    return _context7.finish(19);

                case 27:
                case 'end':
                    return _context7.stop();
            }
        }
    }, _marked6, this, [[3, 15, 19, 27], [20,, 22, 26]]);
}

/**
 * Returns an iterator that computes the given mapper function using arguments
 * from each of the iterables.
 */
function imap(iterable, mapper) {
    var _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step8, value;

    return _regenerator2.default.wrap(function imap$(_context8) {
        while (1) {
            switch (_context8.prev = _context8.next) {
                case 0:
                    _iteratorNormalCompletion7 = true;
                    _didIteratorError7 = false;
                    _iteratorError7 = undefined;
                    _context8.prev = 3;
                    _iterator7 = iterable[Symbol.iterator]();

                case 5:
                    if (_iteratorNormalCompletion7 = (_step8 = _iterator7.next()).done) {
                        _context8.next = 12;
                        break;
                    }

                    value = _step8.value;
                    _context8.next = 9;
                    return mapper(value);

                case 9:
                    _iteratorNormalCompletion7 = true;
                    _context8.next = 5;
                    break;

                case 12:
                    _context8.next = 18;
                    break;

                case 14:
                    _context8.prev = 14;
                    _context8.t0 = _context8['catch'](3);
                    _didIteratorError7 = true;
                    _iteratorError7 = _context8.t0;

                case 18:
                    _context8.prev = 18;
                    _context8.prev = 19;

                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                        _iterator7.return();
                    }

                case 21:
                    _context8.prev = 21;

                    if (!_didIteratorError7) {
                        _context8.next = 24;
                        break;
                    }

                    throw _iteratorError7;

                case 24:
                    return _context8.finish(21);

                case 25:
                    return _context8.finish(18);

                case 26:
                case 'end':
                    return _context8.stop();
            }
        }
    }, _marked7, this, [[3, 14, 18, 26], [19,, 21, 25]]);
}

/**
 * Returns an iterator that returns selected elements from the iterable.  If
 * `start` is non-zero, then elements from the iterable are skipped until start
 * is reached.  Then, elements are returned by making steps of `step` (defaults
 * to 1).  If set to higher than 1, items will be skipped.  If `stop` is
 * provided, then iteration continues until the iterator reached that index,
 * otherwise, the iterable will be fully exhausted.  `islice()` does not
 * support negative values for `start`, `stop`, or `step`.
 */
function islice(iterable, start, stop) {
    var step = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    var pred, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step9, _ref4, _ref5, i, value;

    return _regenerator2.default.wrap(function islice$(_context9) {
        while (1) {
            switch (_context9.prev = _context9.next) {
                case 0:
                    if (!(start < 0)) {
                        _context9.next = 2;
                        break;
                    }

                    throw new Error('start cannot be negative');

                case 2:
                    if (!(typeof stop === 'number' && stop < 0)) {
                        _context9.next = 4;
                        break;
                    }

                    throw new Error('stop cannot be negative');

                case 4:
                    if (!(step < 0)) {
                        _context9.next = 6;
                        break;
                    }

                    throw new Error('step cannot be negative');

                case 6:
                    pred = slicePredicate(start, stop, step);
                    _iteratorNormalCompletion8 = true;
                    _didIteratorError8 = false;
                    _iteratorError8 = undefined;
                    _context9.prev = 10;
                    _iterator8 = (0, _builtins.enumerate)(iterable)[Symbol.iterator]();

                case 12:
                    if (_iteratorNormalCompletion8 = (_step9 = _iterator8.next()).done) {
                        _context9.next = 23;
                        break;
                    }

                    _ref4 = _step9.value;
                    _ref5 = _slicedToArray(_ref4, 2);
                    i = _ref5[0];
                    value = _ref5[1];

                    if (!pred(i)) {
                        _context9.next = 20;
                        break;
                    }

                    _context9.next = 20;
                    return value;

                case 20:
                    _iteratorNormalCompletion8 = true;
                    _context9.next = 12;
                    break;

                case 23:
                    _context9.next = 29;
                    break;

                case 25:
                    _context9.prev = 25;
                    _context9.t0 = _context9['catch'](10);
                    _didIteratorError8 = true;
                    _iteratorError8 = _context9.t0;

                case 29:
                    _context9.prev = 29;
                    _context9.prev = 30;

                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }

                case 32:
                    _context9.prev = 32;

                    if (!_didIteratorError8) {
                        _context9.next = 35;
                        break;
                    }

                    throw _iteratorError8;

                case 35:
                    return _context9.finish(32);

                case 36:
                    return _context9.finish(29);

                case 37:
                case 'end':
                    return _context9.stop();
            }
        }
    }, _marked8, this, [[10, 25, 29, 37], [30,, 32, 36]]);
}

/**
 * Returns an iterator that aggregates elements from each of the iterables.
 * Used for lock-step iteration over several iterables at a time.  When
 * iterating over two iterables, use `izip2`.  When iterating over three
 * iterables, use `izip3`, etc.  `izip` is an alias for `izip2`.
 */
function izip2(xs, ys) {
    var ixs, iys, x, y;
    return _regenerator2.default.wrap(function izip2$(_context10) {
        while (1) {
            switch (_context10.prev = _context10.next) {
                case 0:
                    ixs = (0, _builtins.iter)(xs);
                    iys = (0, _builtins.iter)(ys);

                case 2:
                    x = ixs.next();
                    y = iys.next();

                    if (!(!x.done && !y.done)) {
                        _context10.next = 9;
                        break;
                    }

                    _context10.next = 7;
                    return [x.value, y.value];

                case 7:
                    _context10.next = 10;
                    break;

                case 9:
                    return _context10.abrupt('return');

                case 10:
                    _context10.next = 2;
                    break;

                case 12:
                case 'end':
                    return _context10.stop();
            }
        }
    }, _marked9, this);
}

/**
 * Like izip2, but for three input iterables.
 */
function izip3(xs, ys, zs) {
    var ixs, iys, izs, x, y, z;
    return _regenerator2.default.wrap(function izip3$(_context11) {
        while (1) {
            switch (_context11.prev = _context11.next) {
                case 0:
                    ixs = (0, _builtins.iter)(xs);
                    iys = (0, _builtins.iter)(ys);
                    izs = (0, _builtins.iter)(zs);

                case 3:
                    x = ixs.next();
                    y = iys.next();
                    z = izs.next();

                    if (!(!x.done && !y.done && !z.done)) {
                        _context11.next = 11;
                        break;
                    }

                    _context11.next = 9;
                    return [x.value, y.value, z.value];

                case 9:
                    _context11.next = 12;
                    break;

                case 11:
                    return _context11.abrupt('return');

                case 12:
                    _context11.next = 3;
                    break;

                case 14:
                case 'end':
                    return _context11.stop();
            }
        }
    }, _marked10, this);
}

var izip = exports.izip = izip2;

/**
 * Returns an iterator that aggregates elements from each of the iterables.  If
 * the iterables are of uneven length, missing values are filled-in with
 * fillvalue.  Iteration continues until the longest iterable is exhausted.
 */
function izipLongest2(xs, ys) {
    var filler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    var ixs, iys, x, y;
    return _regenerator2.default.wrap(function izipLongest2$(_context12) {
        while (1) {
            switch (_context12.prev = _context12.next) {
                case 0:
                    ixs = (0, _builtins.iter)(xs);
                    iys = (0, _builtins.iter)(ys);

                case 2:
                    x = ixs.next();
                    y = iys.next();

                    if (!(x.done && y.done)) {
                        _context12.next = 8;
                        break;
                    }

                    return _context12.abrupt('return');

                case 8:
                    _context12.next = 10;
                    return [!x.done ? x.value : filler, !y.done ? y.value : filler];

                case 10:
                    _context12.next = 2;
                    break;

                case 12:
                case 'end':
                    return _context12.stop();
            }
        }
    }, _marked11, this);
}

/**
 * See izipLongest2, but for three.
 */
function izipLongest3(xs, ys, zs) {
    var filler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
    var ixs, iys, izs, x, y, z;
    return _regenerator2.default.wrap(function izipLongest3$(_context13) {
        while (1) {
            switch (_context13.prev = _context13.next) {
                case 0:
                    ixs = (0, _builtins.iter)(xs);
                    iys = (0, _builtins.iter)(ys);
                    izs = (0, _builtins.iter)(zs);

                case 3:
                    x = ixs.next();
                    y = iys.next();
                    z = izs.next();

                    if (!(x.done && y.done && z.done)) {
                        _context13.next = 10;
                        break;
                    }

                    return _context13.abrupt('return');

                case 10:
                    _context13.next = 12;
                    return [!x.done ? x.value : filler, !y.done ? y.value : filler, !z.done ? z.value : filler];

                case 12:
                    _context13.next = 3;
                    break;

                case 14:
                case 'end':
                    return _context13.stop();
            }
        }
    }, _marked12, this);
}

/**
 * Like the other izips (`izip`, `izip3`, etc), but generalized to take an
 * unlimited amount of input iterables.  Think `izip(*iterables)` in Python.
 *
 * **Note:** Due to Flow type system limitations, you can only "generially" zip
 * iterables with homogeneous types, so you cannot mix types like <A, B> like
 * you can with izip2().
 */
function izipMany() {
    for (var _len2 = arguments.length, iters = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        iters[_key2] = arguments[_key2];
    }

    var iterables, heads;
    return _regenerator2.default.wrap(function izipMany$(_context14) {
        while (1) {
            switch (_context14.prev = _context14.next) {
                case 0:
                    // Make them all iterables
                    iterables = iters.map(_builtins.iter);

                case 1:
                    heads = iterables.map(function (xs) {
                        return xs.next();
                    });

                    if (!(0, _builtins.all)(heads, function (h) {
                        return !h.done;
                    })) {
                        _context14.next = 7;
                        break;
                    }

                    _context14.next = 5;
                    return heads.map(function (h) {
                        return h.value;
                    });

                case 5:
                    _context14.next = 8;
                    break;

                case 7:
                    return _context14.abrupt('return');

                case 8:
                    _context14.next = 1;
                    break;

                case 10:
                case 'end':
                    return _context14.stop();
            }
        }
    }, _marked13, this);
}

/**
 * Return successive `r`-length permutations of elements in the iterable.
 *
 * If `r` is not specified, then `r` defaults to the length of the iterable and
 * all possible full-length permutations are generated.
 *
 * Permutations are emitted in lexicographic sort order.  So, if the input
 * iterable is sorted, the permutation tuples will be produced in sorted order.
 *
 * Elements are treated as unique based on their position, not on their value.
 * So if the input elements are unique, there will be no repeat values in each
 * permutation.
 */
function permutations(iterable, r) {
    var pool, n, x, indices, cycles, poolgetter, cleanExit, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step10, i, j, _ref6, p, q;

    return _regenerator2.default.wrap(function permutations$(_context15) {
        while (1) {
            switch (_context15.prev = _context15.next) {
                case 0:
                    pool = [].concat(_toConsumableArray(iterable));
                    n = pool.length;
                    x = r === undefined ? n : r;

                    if (!(x > n)) {
                        _context15.next = 5;
                        break;
                    }

                    return _context15.abrupt('return');

                case 5:
                    indices = [].concat(_toConsumableArray((0, _builtins.range)(n)));
                    cycles = [].concat(_toConsumableArray((0, _builtins.range)(n, n - x, -1)));

                    poolgetter = function poolgetter(i) {
                        return pool[i];
                    };

                    _context15.next = 10;
                    return indices.slice(0, x).map(poolgetter);

                case 10:
                    if (!(n > 0)) {
                        _context15.next = 54;
                        break;
                    }

                    cleanExit = true;
                    _iteratorNormalCompletion9 = true;
                    _didIteratorError9 = false;
                    _iteratorError9 = undefined;
                    _context15.prev = 15;
                    _iterator9 = (0, _builtins.range)(x - 1, -1, -1)[Symbol.iterator]();

                case 17:
                    if (_iteratorNormalCompletion9 = (_step10 = _iterator9.next()).done) {
                        _context15.next = 36;
                        break;
                    }

                    i = _step10.value;

                    cycles[i] -= 1;

                    if (!(cycles[i] === 0)) {
                        _context15.next = 25;
                        break;
                    }

                    indices = indices.slice(0, i).concat(indices.slice(i + 1)).concat(indices.slice(i, i + 1));
                    cycles[i] = n - i;
                    _context15.next = 33;
                    break;

                case 25:
                    j = cycles[i];
                    _ref6 = [indices[indices.length - j], indices[i]], p = _ref6[0], q = _ref6[1];

                    indices[i] = p;
                    indices[indices.length - j] = q;
                    _context15.next = 31;
                    return indices.slice(0, x).map(poolgetter);

                case 31:
                    cleanExit = false;
                    return _context15.abrupt('break', 36);

                case 33:
                    _iteratorNormalCompletion9 = true;
                    _context15.next = 17;
                    break;

                case 36:
                    _context15.next = 42;
                    break;

                case 38:
                    _context15.prev = 38;
                    _context15.t0 = _context15['catch'](15);
                    _didIteratorError9 = true;
                    _iteratorError9 = _context15.t0;

                case 42:
                    _context15.prev = 42;
                    _context15.prev = 43;

                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
                        _iterator9.return();
                    }

                case 45:
                    _context15.prev = 45;

                    if (!_didIteratorError9) {
                        _context15.next = 48;
                        break;
                    }

                    throw _iteratorError9;

                case 48:
                    return _context15.finish(45);

                case 49:
                    return _context15.finish(42);

                case 50:
                    if (!cleanExit) {
                        _context15.next = 52;
                        break;
                    }

                    return _context15.abrupt('return');

                case 52:
                    _context15.next = 10;
                    break;

                case 54:
                case 'end':
                    return _context15.stop();
            }
        }
    }, _marked14, this, [[15, 38, 42, 50], [43,, 45, 49]]);
}

/**
 * Returns an iterator that produces values over and over again.  Runs
 * indefinitely unless the times argument is specified.
 */
function repeat(thing, times) {
    var _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step11, i;

    return _regenerator2.default.wrap(function repeat$(_context16) {
        while (1) {
            switch (_context16.prev = _context16.next) {
                case 0:
                    if (!(times === undefined)) {
                        _context16.next = 7;
                        break;
                    }

                case 1:
                    _context16.next = 3;
                    return thing;

                case 3:
                    _context16.next = 1;
                    break;

                case 5:
                    _context16.next = 33;
                    break;

                case 7:
                    // eslint-disable-next-line no-unused-vars
                    _iteratorNormalCompletion10 = true;
                    _didIteratorError10 = false;
                    _iteratorError10 = undefined;
                    _context16.prev = 10;
                    _iterator10 = (0, _builtins.range)(times)[Symbol.iterator]();

                case 12:
                    if (_iteratorNormalCompletion10 = (_step11 = _iterator10.next()).done) {
                        _context16.next = 19;
                        break;
                    }

                    i = _step11.value;
                    _context16.next = 16;
                    return thing;

                case 16:
                    _iteratorNormalCompletion10 = true;
                    _context16.next = 12;
                    break;

                case 19:
                    _context16.next = 25;
                    break;

                case 21:
                    _context16.prev = 21;
                    _context16.t0 = _context16['catch'](10);
                    _didIteratorError10 = true;
                    _iteratorError10 = _context16.t0;

                case 25:
                    _context16.prev = 25;
                    _context16.prev = 26;

                    if (!_iteratorNormalCompletion10 && _iterator10.return) {
                        _iterator10.return();
                    }

                case 28:
                    _context16.prev = 28;

                    if (!_didIteratorError10) {
                        _context16.next = 31;
                        break;
                    }

                    throw _iteratorError10;

                case 31:
                    return _context16.finish(28);

                case 32:
                    return _context16.finish(25);

                case 33:
                case 'end':
                    return _context16.stop();
            }
        }
    }, _marked15, this, [[10, 21, 25, 33], [26,, 28, 32]]);
}

/**
 * Returns an iterator that produces elements from the iterable as long as the
 * predicate is true.
 */
function takewhile(iterable, predicate) {
    var _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step12, value;

    return _regenerator2.default.wrap(function takewhile$(_context17) {
        while (1) {
            switch (_context17.prev = _context17.next) {
                case 0:
                    _iteratorNormalCompletion11 = true;
                    _didIteratorError11 = false;
                    _iteratorError11 = undefined;
                    _context17.prev = 3;
                    _iterator11 = iterable[Symbol.iterator]();

                case 5:
                    if (_iteratorNormalCompletion11 = (_step12 = _iterator11.next()).done) {
                        _context17.next = 14;
                        break;
                    }

                    value = _step12.value;

                    if (predicate(value)) {
                        _context17.next = 9;
                        break;
                    }

                    return _context17.abrupt('return');

                case 9:
                    _context17.next = 11;
                    return value;

                case 11:
                    _iteratorNormalCompletion11 = true;
                    _context17.next = 5;
                    break;

                case 14:
                    _context17.next = 20;
                    break;

                case 16:
                    _context17.prev = 16;
                    _context17.t0 = _context17['catch'](3);
                    _didIteratorError11 = true;
                    _iteratorError11 = _context17.t0;

                case 20:
                    _context17.prev = 20;
                    _context17.prev = 21;

                    if (!_iteratorNormalCompletion11 && _iterator11.return) {
                        _iterator11.return();
                    }

                case 23:
                    _context17.prev = 23;

                    if (!_didIteratorError11) {
                        _context17.next = 26;
                        break;
                    }

                    throw _iteratorError11;

                case 26:
                    return _context17.finish(23);

                case 27:
                    return _context17.finish(20);

                case 28:
                case 'end':
                    return _context17.stop();
            }
        }
    }, _marked16, this, [[3, 16, 20, 28], [21,, 23, 27]]);
}

function zipLongest2(xs, ys) {
    var filler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    return [].concat(_toConsumableArray(izipLongest2(xs, ys, filler)));
}

function zipLongest3(xs, ys, zs) {
    var filler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

    return [].concat(_toConsumableArray(izipLongest3(xs, ys, zs, filler)));
}

var izipLongest = exports.izipLongest = izipLongest2;
var zipLongest = exports.zipLongest = zipLongest2;

function zipMany() {
    return [].concat(_toConsumableArray(izipMany.apply(undefined, arguments)));
}